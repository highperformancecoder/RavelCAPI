#include "classdesc.h"

#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#endif
#include "pack_base.h"
#include "unpack_base.h"
#include "xml_pack_base.h"
#include "xml_unpack_base.h"
#include "random_init_base.h"
#ifndef CLASSDESC_TYPENAME_ravel__MouseT__MouseTracking
#define CLASSDESC_TYPENAME_ravel__MouseT__MouseTracking
namespace classdesc {
template <> inline std::string typeName<ravel::MouseT::MouseTracking >()
  {return "ravel::MouseT::MouseTracking";}
namespace   {
template <> EnumKey enum_keysData<ravel::MouseT::MouseTracking>::keysData[]=
 {
  {"none",int(ravel::MouseT::none)},
  {"lowerLimit",int(ravel::MouseT::lowerLimit)},
  {"upperLimit",int(ravel::MouseT::upperLimit)}
 };
template <> EnumKeys<ravel::MouseT::MouseTracking> enum_keysData<ravel::MouseT::MouseTracking>::keys(enum_keysData<ravel::MouseT::MouseTracking>::keysData,sizeof(enum_keysData<ravel::MouseT::MouseTracking>::keysData)/sizeof(enum_keysData<ravel::MouseT::MouseTracking>::keysData[0]));
template <> int enumKey<ravel::MouseT::MouseTracking>(const std::string& x){return int(enum_keysData<ravel::MouseT::MouseTracking>::keys(x));}
template <> std::string enumKey<ravel::MouseT::MouseTracking>(int x){return enum_keysData<ravel::MouseT::MouseTracking>::keys(x);}
}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__MouseT
#define CLASSDESC_TYPENAME_ravel__MouseT
namespace classdesc {
template <> inline std::string typeName<ravel::MouseT >()
  {return "ravel::MouseT";}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__FilterCairo_G_
#define CLASSDESC_TYPENAME_ravel__FilterCairo_G_
namespace classdesc {
template < class G >  struct tn<ravel::FilterCairo<G> >
{
static std::string name()
  {return "ravel::FilterCairo< "+typeName<G>()+" > ";}
};
}
#endif
#ifndef CLASSDESC_TYPENAME_classdesc_access__access_xml_pack__ravel____FilterCairo___G____
#define CLASSDESC_TYPENAME_classdesc_access__access_xml_pack__ravel____FilterCairo___G____
namespace classdesc {
template < class G >  struct tn<classdesc_access::access_xml_pack< ravel :: FilterCairo < G >>  >
{
static std::string name()
  {return "classdesc_access::access_xml_pack< "+typeName<G>()+" > ";}
};
}
#endif
#ifndef CLASSDESC_TYPENAME_classdesc_access__access_xml_unpack__ravel____FilterCairo___G____
#define CLASSDESC_TYPENAME_classdesc_access__access_xml_unpack__ravel____FilterCairo___G____
namespace classdesc {
template < class G >  struct tn<classdesc_access::access_xml_unpack< ravel :: FilterCairo < G >>  >
{
static std::string name()
  {return "classdesc_access::access_xml_unpack< "+typeName<G>()+" > ";}
};
}
#endif
#ifndef CLASSDESC_TYPENAME_classdesc_access__access_random_init__ravel____FilterCairo___G____
#define CLASSDESC_TYPENAME_classdesc_access__access_random_init__ravel____FilterCairo___G____
namespace classdesc {
template < class G >  struct tn<classdesc_access::access_random_init< ravel :: FilterCairo < G >>  >
{
static std::string name()
  {return "classdesc_access::access_random_init< "+typeName<G>()+" > ";}
};
}
#endif
namespace classdesc_access {
template <> struct access_pack<enum ::ravel::MouseT::MouseTracking > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::pack(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_pack<struct ::ravel::MouseT > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
}
};
template < class G >  struct access_pack<class ::ravel::FilterCairo<G> > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::pack_onbase(targ,desc+"",classdesc::base_cast<DataCube >::cast(arg));
::pack_onbase(targ,desc+"",classdesc::base_cast<MouseT >::cast(arg));
::pack(targ,desc+".g",arg.g);
::pack(targ,desc+".mouseTracking",arg.mouseTracking);
::pack(targ,desc+".clamp",arg,&ravel::FilterCairo<G>::clamp);
::pack(targ,desc+".setG",arg,&ravel::FilterCairo<G>::setG);
::pack(targ,desc+".width",arg.width);
::pack(targ,desc+".height",arg.height);
::pack(targ,desc+".render",arg,&ravel::FilterCairo<G>::render);
::pack(targ,desc+".onMouse",arg,&ravel::FilterCairo<G>::onMouse);
::pack(targ,desc+".onMouseDown",arg,&ravel::FilterCairo<G>::onMouseDown);
::pack(targ,desc+".onMouseUp",arg,&ravel::FilterCairo<G>::onMouseUp);
}
};
template < class G >  struct access_pack<struct ::classdesc_access::access_xml_pack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::pack_onbase(targ,desc+"",classdesc::base_cast<access_xml_pack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_pack<struct ::classdesc_access::access_xml_unpack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::pack_onbase(targ,desc+"",classdesc::base_cast<access_xml_unpack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_pack<struct ::classdesc_access::access_random_init< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::pack_onbase(targ,desc+"",classdesc::base_cast<access_random_init<ravel::DataCube> >::cast(arg));
}
};
template <> struct access_unpack<enum ::ravel::MouseT::MouseTracking > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::unpack(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_unpack<struct ::ravel::MouseT > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
}
};
template < class G >  struct access_unpack<class ::ravel::FilterCairo<G> > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::unpack_onbase(targ,desc+"",classdesc::base_cast<DataCube >::cast(arg));
::unpack_onbase(targ,desc+"",classdesc::base_cast<MouseT >::cast(arg));
::unpack(targ,desc+".g",arg.g);
::unpack(targ,desc+".mouseTracking",arg.mouseTracking);
::unpack(targ,desc+".clamp",arg,&ravel::FilterCairo<G>::clamp);
::unpack(targ,desc+".setG",arg,&ravel::FilterCairo<G>::setG);
::unpack(targ,desc+".width",arg.width);
::unpack(targ,desc+".height",arg.height);
::unpack(targ,desc+".render",arg,&ravel::FilterCairo<G>::render);
::unpack(targ,desc+".onMouse",arg,&ravel::FilterCairo<G>::onMouse);
::unpack(targ,desc+".onMouseDown",arg,&ravel::FilterCairo<G>::onMouseDown);
::unpack(targ,desc+".onMouseUp",arg,&ravel::FilterCairo<G>::onMouseUp);
}
};
template < class G >  struct access_unpack<struct ::classdesc_access::access_xml_pack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::unpack_onbase(targ,desc+"",classdesc::base_cast<access_xml_pack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_unpack<struct ::classdesc_access::access_xml_unpack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::unpack_onbase(targ,desc+"",classdesc::base_cast<access_xml_unpack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_unpack<struct ::classdesc_access::access_random_init< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::unpack_onbase(targ,desc+"",classdesc::base_cast<access_random_init<ravel::DataCube> >::cast(arg));
}
};
template <> struct access_xml_pack<enum ::ravel::MouseT::MouseTracking > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_pack(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_xml_pack<struct ::ravel::MouseT > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
}
};
template < class G >  struct access_xml_pack<struct ::classdesc_access::access_xml_pack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::xml_pack_onbase(targ,desc+"",classdesc::base_cast<access_xml_pack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_xml_pack<struct ::classdesc_access::access_xml_unpack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::xml_pack_onbase(targ,desc+"",classdesc::base_cast<access_xml_unpack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_xml_pack<struct ::classdesc_access::access_random_init< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::xml_pack_onbase(targ,desc+"",classdesc::base_cast<access_random_init<ravel::DataCube> >::cast(arg));
}
};
template <> struct access_xml_unpack<enum ::ravel::MouseT::MouseTracking > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_unpack(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_xml_unpack<struct ::ravel::MouseT > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
}
};
template < class G >  struct access_xml_unpack<struct ::classdesc_access::access_xml_pack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::xml_unpack_onbase(targ,desc+"",classdesc::base_cast<access_xml_pack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_xml_unpack<struct ::classdesc_access::access_xml_unpack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::xml_unpack_onbase(targ,desc+"",classdesc::base_cast<access_xml_unpack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_xml_unpack<struct ::classdesc_access::access_random_init< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::xml_unpack_onbase(targ,desc+"",classdesc::base_cast<access_random_init<ravel::DataCube> >::cast(arg));
}
};
template <> struct access_random_init<enum ::ravel::MouseT::MouseTracking > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::random_init(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_random_init<struct ::ravel::MouseT > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
}
};
template < class G >  struct access_random_init<struct ::classdesc_access::access_xml_pack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::random_init_onbase(targ,desc+"",classdesc::base_cast<access_xml_pack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_random_init<struct ::classdesc_access::access_xml_unpack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::random_init_onbase(targ,desc+"",classdesc::base_cast<access_xml_unpack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_random_init<struct ::classdesc_access::access_random_init< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::random_init_onbase(targ,desc+"",classdesc::base_cast<access_random_init<ravel::DataCube> >::cast(arg));
}
};
}
#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic pop
#endif
#include "classdesc.h"

#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#endif
#include "TCL_obj_base.h"
#include "isa_base.h"
#ifndef CLASSDESC_TYPENAME_ravel__MouseT__MouseTracking
#define CLASSDESC_TYPENAME_ravel__MouseT__MouseTracking
namespace classdesc {
template <> inline std::string typeName<ravel::MouseT::MouseTracking >()
  {return "ravel::MouseT::MouseTracking";}
namespace   {
template <> EnumKey enum_keysData<ravel::MouseT::MouseTracking>::keysData[]=
 {
  {"none",int(ravel::MouseT::none)},
  {"lowerLimit",int(ravel::MouseT::lowerLimit)},
  {"upperLimit",int(ravel::MouseT::upperLimit)}
 };
template <> EnumKeys<ravel::MouseT::MouseTracking> enum_keysData<ravel::MouseT::MouseTracking>::keys(enum_keysData<ravel::MouseT::MouseTracking>::keysData,sizeof(enum_keysData<ravel::MouseT::MouseTracking>::keysData)/sizeof(enum_keysData<ravel::MouseT::MouseTracking>::keysData[0]));
template <> int enumKey<ravel::MouseT::MouseTracking>(const std::string& x){return int(enum_keysData<ravel::MouseT::MouseTracking>::keys(x));}
template <> std::string enumKey<ravel::MouseT::MouseTracking>(int x){return enum_keysData<ravel::MouseT::MouseTracking>::keys(x);}
}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__MouseT
#define CLASSDESC_TYPENAME_ravel__MouseT
namespace classdesc {
template <> inline std::string typeName<ravel::MouseT >()
  {return "ravel::MouseT";}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__FilterCairo_G_
#define CLASSDESC_TYPENAME_ravel__FilterCairo_G_
namespace classdesc {
template < class G >  struct tn<ravel::FilterCairo<G> >
{
static std::string name()
  {return "ravel::FilterCairo< "+typeName<G>()+" > ";}
};
}
#endif
#ifndef CLASSDESC_TYPENAME_classdesc_access__access_xml_pack__ravel____FilterCairo___G____
#define CLASSDESC_TYPENAME_classdesc_access__access_xml_pack__ravel____FilterCairo___G____
namespace classdesc {
template < class G >  struct tn<classdesc_access::access_xml_pack< ravel :: FilterCairo < G >>  >
{
static std::string name()
  {return "classdesc_access::access_xml_pack< "+typeName<G>()+" > ";}
};
}
#endif
#ifndef CLASSDESC_TYPENAME_classdesc_access__access_xml_unpack__ravel____FilterCairo___G____
#define CLASSDESC_TYPENAME_classdesc_access__access_xml_unpack__ravel____FilterCairo___G____
namespace classdesc {
template < class G >  struct tn<classdesc_access::access_xml_unpack< ravel :: FilterCairo < G >>  >
{
static std::string name()
  {return "classdesc_access::access_xml_unpack< "+typeName<G>()+" > ";}
};
}
#endif
#ifndef CLASSDESC_TYPENAME_classdesc_access__access_random_init__ravel____FilterCairo___G____
#define CLASSDESC_TYPENAME_classdesc_access__access_random_init__ravel____FilterCairo___G____
namespace classdesc {
template < class G >  struct tn<classdesc_access::access_random_init< ravel :: FilterCairo < G >>  >
{
static std::string name()
  {return "classdesc_access::access_random_init< "+typeName<G>()+" > ";}
};
}
#endif
namespace classdesc_access {
template <> struct access_TCL_obj<enum ::ravel::MouseT::MouseTracking > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::TCL_obj(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_TCL_obj<struct ::ravel::MouseT > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
}
};
template < class G >  struct access_TCL_obj<class ::ravel::FilterCairo<G> > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::TCL_obj_onbase(targ,desc+"",classdesc::base_cast<DataCube >::cast(arg));
::TCL_obj_onbase(targ,desc+"",classdesc::base_cast<MouseT >::cast(arg));
::TCL_obj(targ,desc+".setG",arg,&ravel::FilterCairo<G>::setG);
::TCL_obj(targ,desc+".width",arg.width);
::TCL_obj(targ,desc+".height",arg.height);
::TCL_obj(targ,desc+".render",arg,&ravel::FilterCairo<G>::render);
::TCL_obj(targ,desc+".onMouse",arg,&ravel::FilterCairo<G>::onMouse);
::TCL_obj(targ,desc+".onMouseDown",arg,&ravel::FilterCairo<G>::onMouseDown);
::TCL_obj(targ,desc+".onMouseUp",arg,&ravel::FilterCairo<G>::onMouseUp);
}
};
template < class G >  struct access_TCL_obj<struct ::classdesc_access::access_xml_pack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::TCL_obj_onbase(targ,desc+"",classdesc::base_cast<access_xml_pack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_TCL_obj<struct ::classdesc_access::access_xml_unpack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::TCL_obj_onbase(targ,desc+"",classdesc::base_cast<access_xml_unpack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_TCL_obj<struct ::classdesc_access::access_random_init< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::TCL_obj_onbase(targ,desc+"",classdesc::base_cast<access_random_init<ravel::DataCube> >::cast(arg));
}
};
template <> struct access_isa<enum ::ravel::MouseT::MouseTracking > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::isa(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_isa<struct ::ravel::MouseT > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
}
};
template < class G >  struct access_isa<class ::ravel::FilterCairo<G> > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::isa_onbase(targ,desc+"",classdesc::base_cast<DataCube >::cast(arg));
::isa_onbase(targ,desc+"",classdesc::base_cast<MouseT >::cast(arg));
::isa(targ,desc+".setG",arg,&ravel::FilterCairo<G>::setG);
::isa(targ,desc+".width",arg.width);
::isa(targ,desc+".height",arg.height);
::isa(targ,desc+".render",arg,&ravel::FilterCairo<G>::render);
::isa(targ,desc+".onMouse",arg,&ravel::FilterCairo<G>::onMouse);
::isa(targ,desc+".onMouseDown",arg,&ravel::FilterCairo<G>::onMouseDown);
::isa(targ,desc+".onMouseUp",arg,&ravel::FilterCairo<G>::onMouseUp);
}
};
template < class G >  struct access_isa<struct ::classdesc_access::access_xml_pack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::isa_onbase(targ,desc+"",classdesc::base_cast<access_xml_pack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_isa<struct ::classdesc_access::access_xml_unpack< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::isa_onbase(targ,desc+"",classdesc::base_cast<access_xml_unpack<ravel::DataCube> >::cast(arg));
}
};
template < class G >  struct access_isa<struct ::classdesc_access::access_random_init< ravel :: FilterCairo < G >>  > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace classdesc_access;
::isa_onbase(targ,desc+"",classdesc::base_cast<access_random_init<ravel::DataCube> >::cast(arg));
}
};
}
#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic pop
#endif
