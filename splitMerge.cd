#include "classdesc.h"

#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#endif
#include "pack_base.h"
#include "unpack_base.h"
#include "xml_pack_base.h"
#include "xml_unpack_base.h"
#include "random_init_base.h"
#ifndef CLASSDESC_TYPENAME_ravel__ColRow
#define CLASSDESC_TYPENAME_ravel__ColRow
namespace classdesc {
template <> inline std::string typeName<ravel::ColRow >()
  {return "ravel::ColRow";}
namespace   {
template <> EnumKey enum_keysData<ravel::ColRow>::keysData[]=
 {
  {"col",int(ravel::col)},
  {"row",int(ravel::row)}
 };
template <> EnumKeys<ravel::ColRow> enum_keysData<ravel::ColRow>::keys(enum_keysData<ravel::ColRow>::keysData,sizeof(enum_keysData<ravel::ColRow>::keysData)/sizeof(enum_keysData<ravel::ColRow>::keysData[0]));
template <> int enumKey<ravel::ColRow>(const std::string& x){return int(enum_keysData<ravel::ColRow>::keys(x));}
template <> std::string enumKey<ravel::ColRow>(int x){return enum_keysData<ravel::ColRow>::keys(x);}
}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__SplitMerge
#define CLASSDESC_TYPENAME_ravel__SplitMerge
namespace classdesc {
template <> inline std::string typeName<ravel::SplitMerge >()
  {return "ravel::SplitMerge";}
}
#endif
namespace classdesc_access {
template <> struct access_pack<enum ::ravel::ColRow > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::pack(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_pack<class ::ravel::SplitMerge > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::pack(targ,desc+".elem",arg.elem);
::pack(targ,desc+".splitPoint",arg,&ravel::SplitMerge::splitPoint);
::pack(targ,desc+".get",arg,&ravel::SplitMerge::get);
::pack(targ,desc+".set",arg,&ravel::SplitMerge::set);
::pack(targ,desc+".startRow",arg,&ravel::SplitMerge::startRow);
::pack(targ,desc+".startCol",arg,&ravel::SplitMerge::startCol);
::pack(targ,desc+".numRows",arg,&ravel::SplitMerge::numRows);
::pack(targ,desc+".numCols",arg,&ravel::SplitMerge::numCols);
::pack(targ,desc+".insertRows",arg,&ravel::SplitMerge::insertRows);
::pack(targ,desc+".insertCols",arg,&ravel::SplitMerge::insertCols);
::pack(targ,desc+".deleteRows",arg,&ravel::SplitMerge::deleteRows);
::pack(targ,desc+".deleteCols",arg,&ravel::SplitMerge::deleteCols);
::pack(targ,desc+".splitRow",arg,&ravel::SplitMerge::splitRow);
::pack(targ,desc+".splitCol",arg,&ravel::SplitMerge::splitCol);
::pack(targ,desc+".mergeRows",arg,&ravel::SplitMerge::mergeRows);
::pack(targ,desc+".mergeCols",arg,&ravel::SplitMerge::mergeCols);
}
};
template <> struct access_unpack<enum ::ravel::ColRow > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::unpack(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_unpack<class ::ravel::SplitMerge > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::unpack(targ,desc+".elem",arg.elem);
::unpack(targ,desc+".splitPoint",arg,&ravel::SplitMerge::splitPoint);
::unpack(targ,desc+".get",arg,&ravel::SplitMerge::get);
::unpack(targ,desc+".set",arg,&ravel::SplitMerge::set);
::unpack(targ,desc+".startRow",arg,&ravel::SplitMerge::startRow);
::unpack(targ,desc+".startCol",arg,&ravel::SplitMerge::startCol);
::unpack(targ,desc+".numRows",arg,&ravel::SplitMerge::numRows);
::unpack(targ,desc+".numCols",arg,&ravel::SplitMerge::numCols);
::unpack(targ,desc+".insertRows",arg,&ravel::SplitMerge::insertRows);
::unpack(targ,desc+".insertCols",arg,&ravel::SplitMerge::insertCols);
::unpack(targ,desc+".deleteRows",arg,&ravel::SplitMerge::deleteRows);
::unpack(targ,desc+".deleteCols",arg,&ravel::SplitMerge::deleteCols);
::unpack(targ,desc+".splitRow",arg,&ravel::SplitMerge::splitRow);
::unpack(targ,desc+".splitCol",arg,&ravel::SplitMerge::splitCol);
::unpack(targ,desc+".mergeRows",arg,&ravel::SplitMerge::mergeRows);
::unpack(targ,desc+".mergeCols",arg,&ravel::SplitMerge::mergeCols);
}
};
template <> struct access_xml_pack<enum ::ravel::ColRow > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_pack(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_xml_pack<class ::ravel::SplitMerge > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_pack(targ,desc+".elem",arg.elem);
::xml_pack(targ,desc+".splitPoint",arg,&ravel::SplitMerge::splitPoint);
::xml_pack(targ,desc+".get",arg,&ravel::SplitMerge::get);
::xml_pack(targ,desc+".set",arg,&ravel::SplitMerge::set);
::xml_pack(targ,desc+".startRow",arg,&ravel::SplitMerge::startRow);
::xml_pack(targ,desc+".startCol",arg,&ravel::SplitMerge::startCol);
::xml_pack(targ,desc+".numRows",arg,&ravel::SplitMerge::numRows);
::xml_pack(targ,desc+".numCols",arg,&ravel::SplitMerge::numCols);
::xml_pack(targ,desc+".insertRows",arg,&ravel::SplitMerge::insertRows);
::xml_pack(targ,desc+".insertCols",arg,&ravel::SplitMerge::insertCols);
::xml_pack(targ,desc+".deleteRows",arg,&ravel::SplitMerge::deleteRows);
::xml_pack(targ,desc+".deleteCols",arg,&ravel::SplitMerge::deleteCols);
::xml_pack(targ,desc+".splitRow",arg,&ravel::SplitMerge::splitRow);
::xml_pack(targ,desc+".splitCol",arg,&ravel::SplitMerge::splitCol);
::xml_pack(targ,desc+".mergeRows",arg,&ravel::SplitMerge::mergeRows);
::xml_pack(targ,desc+".mergeCols",arg,&ravel::SplitMerge::mergeCols);
}
};
template <> struct access_xml_unpack<enum ::ravel::ColRow > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_unpack(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_xml_unpack<class ::ravel::SplitMerge > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_unpack(targ,desc+".elem",arg.elem);
::xml_unpack(targ,desc+".splitPoint",arg,&ravel::SplitMerge::splitPoint);
::xml_unpack(targ,desc+".get",arg,&ravel::SplitMerge::get);
::xml_unpack(targ,desc+".set",arg,&ravel::SplitMerge::set);
::xml_unpack(targ,desc+".startRow",arg,&ravel::SplitMerge::startRow);
::xml_unpack(targ,desc+".startCol",arg,&ravel::SplitMerge::startCol);
::xml_unpack(targ,desc+".numRows",arg,&ravel::SplitMerge::numRows);
::xml_unpack(targ,desc+".numCols",arg,&ravel::SplitMerge::numCols);
::xml_unpack(targ,desc+".insertRows",arg,&ravel::SplitMerge::insertRows);
::xml_unpack(targ,desc+".insertCols",arg,&ravel::SplitMerge::insertCols);
::xml_unpack(targ,desc+".deleteRows",arg,&ravel::SplitMerge::deleteRows);
::xml_unpack(targ,desc+".deleteCols",arg,&ravel::SplitMerge::deleteCols);
::xml_unpack(targ,desc+".splitRow",arg,&ravel::SplitMerge::splitRow);
::xml_unpack(targ,desc+".splitCol",arg,&ravel::SplitMerge::splitCol);
::xml_unpack(targ,desc+".mergeRows",arg,&ravel::SplitMerge::mergeRows);
::xml_unpack(targ,desc+".mergeCols",arg,&ravel::SplitMerge::mergeCols);
}
};
template <> struct access_random_init<enum ::ravel::ColRow > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::random_init(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_random_init<class ::ravel::SplitMerge > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::random_init(targ,desc+".elem",arg.elem);
::random_init(targ,desc+".splitPoint",arg,&ravel::SplitMerge::splitPoint);
::random_init(targ,desc+".get",arg,&ravel::SplitMerge::get);
::random_init(targ,desc+".set",arg,&ravel::SplitMerge::set);
::random_init(targ,desc+".startRow",arg,&ravel::SplitMerge::startRow);
::random_init(targ,desc+".startCol",arg,&ravel::SplitMerge::startCol);
::random_init(targ,desc+".numRows",arg,&ravel::SplitMerge::numRows);
::random_init(targ,desc+".numCols",arg,&ravel::SplitMerge::numCols);
::random_init(targ,desc+".insertRows",arg,&ravel::SplitMerge::insertRows);
::random_init(targ,desc+".insertCols",arg,&ravel::SplitMerge::insertCols);
::random_init(targ,desc+".deleteRows",arg,&ravel::SplitMerge::deleteRows);
::random_init(targ,desc+".deleteCols",arg,&ravel::SplitMerge::deleteCols);
::random_init(targ,desc+".splitRow",arg,&ravel::SplitMerge::splitRow);
::random_init(targ,desc+".splitCol",arg,&ravel::SplitMerge::splitCol);
::random_init(targ,desc+".mergeRows",arg,&ravel::SplitMerge::mergeRows);
::random_init(targ,desc+".mergeCols",arg,&ravel::SplitMerge::mergeCols);
}
};
}
#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic pop
#endif
#include "classdesc.h"

#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#endif
#include "TCL_obj_base.h"
#include "isa_base.h"
#ifndef CLASSDESC_TYPENAME_ravel__ColRow
#define CLASSDESC_TYPENAME_ravel__ColRow
namespace classdesc {
template <> inline std::string typeName<ravel::ColRow >()
  {return "ravel::ColRow";}
namespace   {
template <> EnumKey enum_keysData<ravel::ColRow>::keysData[]=
 {
  {"col",int(ravel::col)},
  {"row",int(ravel::row)}
 };
template <> EnumKeys<ravel::ColRow> enum_keysData<ravel::ColRow>::keys(enum_keysData<ravel::ColRow>::keysData,sizeof(enum_keysData<ravel::ColRow>::keysData)/sizeof(enum_keysData<ravel::ColRow>::keysData[0]));
template <> int enumKey<ravel::ColRow>(const std::string& x){return int(enum_keysData<ravel::ColRow>::keys(x));}
template <> std::string enumKey<ravel::ColRow>(int x){return enum_keysData<ravel::ColRow>::keys(x);}
}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__SplitMerge
#define CLASSDESC_TYPENAME_ravel__SplitMerge
namespace classdesc {
template <> inline std::string typeName<ravel::SplitMerge >()
  {return "ravel::SplitMerge";}
}
#endif
namespace classdesc_access {
template <> struct access_TCL_obj<enum ::ravel::ColRow > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::TCL_obj(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_TCL_obj<class ::ravel::SplitMerge > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::TCL_obj(targ,desc+".get",arg,&ravel::SplitMerge::get);
::TCL_obj(targ,desc+".set",arg,&ravel::SplitMerge::set);
::TCL_obj(targ,desc+".startRow",arg,&ravel::SplitMerge::startRow);
::TCL_obj(targ,desc+".startCol",arg,&ravel::SplitMerge::startCol);
::TCL_obj(targ,desc+".numRows",arg,&ravel::SplitMerge::numRows);
::TCL_obj(targ,desc+".numCols",arg,&ravel::SplitMerge::numCols);
::TCL_obj(targ,desc+".insertRows",arg,&ravel::SplitMerge::insertRows);
::TCL_obj(targ,desc+".insertCols",arg,&ravel::SplitMerge::insertCols);
::TCL_obj(targ,desc+".deleteRows",arg,&ravel::SplitMerge::deleteRows);
::TCL_obj(targ,desc+".deleteCols",arg,&ravel::SplitMerge::deleteCols);
::TCL_obj(targ,desc+".splitRow",arg,&ravel::SplitMerge::splitRow);
::TCL_obj(targ,desc+".splitCol",arg,&ravel::SplitMerge::splitCol);
::TCL_obj(targ,desc+".mergeRows",arg,&ravel::SplitMerge::mergeRows);
::TCL_obj(targ,desc+".mergeCols",arg,&ravel::SplitMerge::mergeCols);
}
};
template <> struct access_isa<enum ::ravel::ColRow > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::isa(targ,desc+"",classdesc::enum_handle(arg));
}
};
template <> struct access_isa<class ::ravel::SplitMerge > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::isa(targ,desc+".get",arg,&ravel::SplitMerge::get);
::isa(targ,desc+".set",arg,&ravel::SplitMerge::set);
::isa(targ,desc+".startRow",arg,&ravel::SplitMerge::startRow);
::isa(targ,desc+".startCol",arg,&ravel::SplitMerge::startCol);
::isa(targ,desc+".numRows",arg,&ravel::SplitMerge::numRows);
::isa(targ,desc+".numCols",arg,&ravel::SplitMerge::numCols);
::isa(targ,desc+".insertRows",arg,&ravel::SplitMerge::insertRows);
::isa(targ,desc+".insertCols",arg,&ravel::SplitMerge::insertCols);
::isa(targ,desc+".deleteRows",arg,&ravel::SplitMerge::deleteRows);
::isa(targ,desc+".deleteCols",arg,&ravel::SplitMerge::deleteCols);
::isa(targ,desc+".splitRow",arg,&ravel::SplitMerge::splitRow);
::isa(targ,desc+".splitCol",arg,&ravel::SplitMerge::splitCol);
::isa(targ,desc+".mergeRows",arg,&ravel::SplitMerge::mergeRows);
::isa(targ,desc+".mergeCols",arg,&ravel::SplitMerge::mergeCols);
}
};
}
#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic pop
#endif
