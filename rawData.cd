#include "classdesc.h"

#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#endif
#include "pack_base.h"
#include "unpack_base.h"
#include "xml_pack_base.h"
#include "xml_unpack_base.h"
#include "random_init_base.h"
#ifndef CLASSDESC_TYPENAME_ravel__InvalidKey
#define CLASSDESC_TYPENAME_ravel__InvalidKey
namespace classdesc {
template <> inline std::string typeName<ravel::InvalidKey >()
  {return "ravel::InvalidKey";}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__RawDataIdx__Idx
#define CLASSDESC_TYPENAME_ravel__RawDataIdx__Idx
namespace classdesc {
template <> inline std::string typeName<ravel::RawDataIdx::Idx >()
  {return "ravel::RawDataIdx::Idx";}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__RawDataIdx__SizeStride
#define CLASSDESC_TYPENAME_ravel__RawDataIdx__SizeStride
namespace classdesc {
template <> inline std::string typeName<ravel::RawDataIdx::SizeStride >()
  {return "ravel::RawDataIdx::SizeStride";}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__RawDataIdx
#define CLASSDESC_TYPENAME_ravel__RawDataIdx
namespace classdesc {
template <> inline std::string typeName<ravel::RawDataIdx >()
  {return "ravel::RawDataIdx";}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__RawData
#define CLASSDESC_TYPENAME_ravel__RawData
namespace classdesc {
template <> inline std::string typeName<ravel::RawData >()
  {return "ravel::RawData";}
}
#endif
namespace classdesc_access {
template <> struct access_pack<struct ::ravel::InvalidKey > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::pack_onbase(targ,desc+"",classdesc::base_cast<std::exception >::cast(arg));
::pack(targ,desc+".what",arg,&ravel::InvalidKey::what);
}
};
template <> struct access_pack<struct ::ravel::RawDataIdx::Idx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::pack(targ,desc+".idx",arg.idx);
::pack(targ,desc+".stride",arg.stride);
}
};
template <> struct access_pack<struct ::ravel::RawDataIdx::SizeStride > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::pack(targ,desc+".size",arg.size);
::pack(targ,desc+".stride",arg.stride);
}
};
template <> struct access_pack<class ::ravel::RawDataIdx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::pack(targ,desc+".indicesByName",arg.indicesByName);
::pack(targ,desc+".indices",arg.indices);
::pack(targ,desc+".m_size",arg.m_size);
::pack(targ,desc+".m_offset",arg.m_offset);
::pack(targ,desc+".index",arg,&ravel::RawDataIdx::index);
::pack(targ,desc+".normalise",arg,&ravel::RawDataIdx::normalise);
::pack(targ,desc+".clear",arg,&ravel::RawDataIdx::clear);
::pack(targ,desc+".renameAxis",arg,&ravel::RawDataIdx::renameAxis);
::pack(targ,desc+".size",arg,&ravel::RawDataIdx::size);
::pack(targ,desc+".rank",arg,&ravel::RawDataIdx::rank);
::pack(targ,desc+".idx",arg,&ravel::RawDataIdx::idx);
::pack(targ,desc+".offset",arg,&ravel::RawDataIdx::offset);
::pack(targ,desc+".sizeStride",arg,&ravel::RawDataIdx::sizeStride);
::pack(targ,desc+".slice",arg,&ravel::RawDataIdx::slice);
::pack(targ,desc+".removeDimension",arg,&ravel::RawDataIdx::removeDimension);
}
};
template <> struct access_pack<class ::ravel::RawData > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::pack_onbase(targ,desc+"",classdesc::base_cast<RawDataIdx >::cast(arg));
::pack(targ,desc+".data",arg.data);
::pack(targ,desc+".clear",arg,&ravel::RawData::clear);
::pack(targ,desc+".reduce",arg,&ravel::RawData::reduce);
::pack(targ,desc+".reduceAlong",arg,&ravel::RawData::reduceAlong);
}
};
template <> struct access_unpack<struct ::ravel::InvalidKey > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::unpack_onbase(targ,desc+"",classdesc::base_cast<std::exception >::cast(arg));
::unpack(targ,desc+".what",arg,&ravel::InvalidKey::what);
}
};
template <> struct access_unpack<struct ::ravel::RawDataIdx::Idx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::unpack(targ,desc+".idx",arg.idx);
::unpack(targ,desc+".stride",arg.stride);
}
};
template <> struct access_unpack<struct ::ravel::RawDataIdx::SizeStride > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::unpack(targ,desc+".size",arg.size);
::unpack(targ,desc+".stride",arg.stride);
}
};
template <> struct access_unpack<class ::ravel::RawDataIdx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::unpack(targ,desc+".indicesByName",arg.indicesByName);
::unpack(targ,desc+".indices",arg.indices);
::unpack(targ,desc+".m_size",arg.m_size);
::unpack(targ,desc+".m_offset",arg.m_offset);
::unpack(targ,desc+".index",arg,&ravel::RawDataIdx::index);
::unpack(targ,desc+".normalise",arg,&ravel::RawDataIdx::normalise);
::unpack(targ,desc+".clear",arg,&ravel::RawDataIdx::clear);
::unpack(targ,desc+".renameAxis",arg,&ravel::RawDataIdx::renameAxis);
::unpack(targ,desc+".size",arg,&ravel::RawDataIdx::size);
::unpack(targ,desc+".rank",arg,&ravel::RawDataIdx::rank);
::unpack(targ,desc+".idx",arg,&ravel::RawDataIdx::idx);
::unpack(targ,desc+".offset",arg,&ravel::RawDataIdx::offset);
::unpack(targ,desc+".sizeStride",arg,&ravel::RawDataIdx::sizeStride);
::unpack(targ,desc+".slice",arg,&ravel::RawDataIdx::slice);
::unpack(targ,desc+".removeDimension",arg,&ravel::RawDataIdx::removeDimension);
}
};
template <> struct access_unpack<class ::ravel::RawData > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::unpack_onbase(targ,desc+"",classdesc::base_cast<RawDataIdx >::cast(arg));
::unpack(targ,desc+".data",arg.data);
::unpack(targ,desc+".clear",arg,&ravel::RawData::clear);
::unpack(targ,desc+".reduce",arg,&ravel::RawData::reduce);
::unpack(targ,desc+".reduceAlong",arg,&ravel::RawData::reduceAlong);
}
};
template <> struct access_xml_pack<struct ::ravel::InvalidKey > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_pack_onbase(targ,desc+"",classdesc::base_cast<std::exception >::cast(arg));
::xml_pack(targ,desc+".what",arg,&ravel::InvalidKey::what);
}
};
template <> struct access_xml_pack<struct ::ravel::RawDataIdx::Idx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::xml_pack(targ,desc+".idx",arg.idx);
::xml_pack(targ,desc+".stride",arg.stride);
}
};
template <> struct access_xml_pack<struct ::ravel::RawDataIdx::SizeStride > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::xml_pack(targ,desc+".size",arg.size);
::xml_pack(targ,desc+".stride",arg.stride);
}
};
template <> struct access_xml_pack<class ::ravel::RawDataIdx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_pack(targ,desc+".indicesByName",arg.indicesByName);
::xml_pack(targ,desc+".indices",arg.indices);
::xml_pack(targ,desc+".m_size",arg.m_size);
::xml_pack(targ,desc+".m_offset",arg.m_offset);
::xml_pack(targ,desc+".index",arg,&ravel::RawDataIdx::index);
::xml_pack(targ,desc+".normalise",arg,&ravel::RawDataIdx::normalise);
::xml_pack(targ,desc+".clear",arg,&ravel::RawDataIdx::clear);
::xml_pack(targ,desc+".renameAxis",arg,&ravel::RawDataIdx::renameAxis);
::xml_pack(targ,desc+".size",arg,&ravel::RawDataIdx::size);
::xml_pack(targ,desc+".rank",arg,&ravel::RawDataIdx::rank);
::xml_pack(targ,desc+".idx",arg,&ravel::RawDataIdx::idx);
::xml_pack(targ,desc+".offset",arg,&ravel::RawDataIdx::offset);
::xml_pack(targ,desc+".sizeStride",arg,&ravel::RawDataIdx::sizeStride);
::xml_pack(targ,desc+".slice",arg,&ravel::RawDataIdx::slice);
::xml_pack(targ,desc+".removeDimension",arg,&ravel::RawDataIdx::removeDimension);
}
};
template <> struct access_xml_pack<class ::ravel::RawData > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_pack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_pack_onbase(targ,desc+"",classdesc::base_cast<RawDataIdx >::cast(arg));
::xml_pack(targ,desc+".data",arg.data);
::xml_pack(targ,desc+".clear",arg,&ravel::RawData::clear);
::xml_pack(targ,desc+".reduce",arg,&ravel::RawData::reduce);
::xml_pack(targ,desc+".reduceAlong",arg,&ravel::RawData::reduceAlong);
}
};
template <> struct access_xml_unpack<struct ::ravel::InvalidKey > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_unpack_onbase(targ,desc+"",classdesc::base_cast<std::exception >::cast(arg));
::xml_unpack(targ,desc+".what",arg,&ravel::InvalidKey::what);
}
};
template <> struct access_xml_unpack<struct ::ravel::RawDataIdx::Idx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::xml_unpack(targ,desc+".idx",arg.idx);
::xml_unpack(targ,desc+".stride",arg.stride);
}
};
template <> struct access_xml_unpack<struct ::ravel::RawDataIdx::SizeStride > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::xml_unpack(targ,desc+".size",arg.size);
::xml_unpack(targ,desc+".stride",arg.stride);
}
};
template <> struct access_xml_unpack<class ::ravel::RawDataIdx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_unpack(targ,desc+".indicesByName",arg.indicesByName);
::xml_unpack(targ,desc+".indices",arg.indices);
::xml_unpack(targ,desc+".m_size",arg.m_size);
::xml_unpack(targ,desc+".m_offset",arg.m_offset);
::xml_unpack(targ,desc+".index",arg,&ravel::RawDataIdx::index);
::xml_unpack(targ,desc+".normalise",arg,&ravel::RawDataIdx::normalise);
::xml_unpack(targ,desc+".clear",arg,&ravel::RawDataIdx::clear);
::xml_unpack(targ,desc+".renameAxis",arg,&ravel::RawDataIdx::renameAxis);
::xml_unpack(targ,desc+".size",arg,&ravel::RawDataIdx::size);
::xml_unpack(targ,desc+".rank",arg,&ravel::RawDataIdx::rank);
::xml_unpack(targ,desc+".idx",arg,&ravel::RawDataIdx::idx);
::xml_unpack(targ,desc+".offset",arg,&ravel::RawDataIdx::offset);
::xml_unpack(targ,desc+".sizeStride",arg,&ravel::RawDataIdx::sizeStride);
::xml_unpack(targ,desc+".slice",arg,&ravel::RawDataIdx::slice);
::xml_unpack(targ,desc+".removeDimension",arg,&ravel::RawDataIdx::removeDimension);
}
};
template <> struct access_xml_unpack<class ::ravel::RawData > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::xml_unpack_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::xml_unpack_onbase(targ,desc+"",classdesc::base_cast<RawDataIdx >::cast(arg));
::xml_unpack(targ,desc+".data",arg.data);
::xml_unpack(targ,desc+".clear",arg,&ravel::RawData::clear);
::xml_unpack(targ,desc+".reduce",arg,&ravel::RawData::reduce);
::xml_unpack(targ,desc+".reduceAlong",arg,&ravel::RawData::reduceAlong);
}
};
template <> struct access_random_init<struct ::ravel::InvalidKey > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::random_init_onbase(targ,desc+"",classdesc::base_cast<std::exception >::cast(arg));
::random_init(targ,desc+".what",arg,&ravel::InvalidKey::what);
}
};
template <> struct access_random_init<struct ::ravel::RawDataIdx::Idx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::random_init(targ,desc+".idx",arg.idx);
::random_init(targ,desc+".stride",arg.stride);
}
};
template <> struct access_random_init<struct ::ravel::RawDataIdx::SizeStride > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::random_init(targ,desc+".size",arg.size);
::random_init(targ,desc+".stride",arg.stride);
}
};
template <> struct access_random_init<class ::ravel::RawDataIdx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::random_init(targ,desc+".indicesByName",arg.indicesByName);
::random_init(targ,desc+".indices",arg.indices);
::random_init(targ,desc+".m_size",arg.m_size);
::random_init(targ,desc+".m_offset",arg.m_offset);
::random_init(targ,desc+".index",arg,&ravel::RawDataIdx::index);
::random_init(targ,desc+".normalise",arg,&ravel::RawDataIdx::normalise);
::random_init(targ,desc+".clear",arg,&ravel::RawDataIdx::clear);
::random_init(targ,desc+".renameAxis",arg,&ravel::RawDataIdx::renameAxis);
::random_init(targ,desc+".size",arg,&ravel::RawDataIdx::size);
::random_init(targ,desc+".rank",arg,&ravel::RawDataIdx::rank);
::random_init(targ,desc+".idx",arg,&ravel::RawDataIdx::idx);
::random_init(targ,desc+".offset",arg,&ravel::RawDataIdx::offset);
::random_init(targ,desc+".sizeStride",arg,&ravel::RawDataIdx::sizeStride);
::random_init(targ,desc+".slice",arg,&ravel::RawDataIdx::slice);
::random_init(targ,desc+".removeDimension",arg,&ravel::RawDataIdx::removeDimension);
}
};
template <> struct access_random_init<class ::ravel::RawData > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::random_init_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::random_init_onbase(targ,desc+"",classdesc::base_cast<RawDataIdx >::cast(arg));
::random_init(targ,desc+".data",arg.data);
::random_init(targ,desc+".clear",arg,&ravel::RawData::clear);
::random_init(targ,desc+".reduce",arg,&ravel::RawData::reduce);
::random_init(targ,desc+".reduceAlong",arg,&ravel::RawData::reduceAlong);
}
};
}
#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic pop
#endif
#include "classdesc.h"

#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-function"
#endif
#include "TCL_obj_base.h"
#include "isa_base.h"
#ifndef CLASSDESC_TYPENAME_ravel__InvalidKey
#define CLASSDESC_TYPENAME_ravel__InvalidKey
namespace classdesc {
template <> inline std::string typeName<ravel::InvalidKey >()
  {return "ravel::InvalidKey";}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__RawDataIdx__Idx
#define CLASSDESC_TYPENAME_ravel__RawDataIdx__Idx
namespace classdesc {
template <> inline std::string typeName<ravel::RawDataIdx::Idx >()
  {return "ravel::RawDataIdx::Idx";}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__RawDataIdx__SizeStride
#define CLASSDESC_TYPENAME_ravel__RawDataIdx__SizeStride
namespace classdesc {
template <> inline std::string typeName<ravel::RawDataIdx::SizeStride >()
  {return "ravel::RawDataIdx::SizeStride";}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__RawDataIdx
#define CLASSDESC_TYPENAME_ravel__RawDataIdx
namespace classdesc {
template <> inline std::string typeName<ravel::RawDataIdx >()
  {return "ravel::RawDataIdx";}
}
#endif
#ifndef CLASSDESC_TYPENAME_ravel__RawData
#define CLASSDESC_TYPENAME_ravel__RawData
namespace classdesc {
template <> inline std::string typeName<ravel::RawData >()
  {return "ravel::RawData";}
}
#endif
namespace classdesc_access {
template <> struct access_TCL_obj<struct ::ravel::InvalidKey > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::TCL_obj_onbase(targ,desc+"",classdesc::base_cast<std::exception >::cast(arg));
::TCL_obj(targ,desc+".what",arg,&ravel::InvalidKey::what);
}
};
template <> struct access_TCL_obj<struct ::ravel::RawDataIdx::Idx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::TCL_obj(targ,desc+".idx",arg.idx);
::TCL_obj(targ,desc+".stride",arg.stride);
}
};
template <> struct access_TCL_obj<struct ::ravel::RawDataIdx::SizeStride > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::TCL_obj(targ,desc+".size",arg.size);
::TCL_obj(targ,desc+".stride",arg.stride);
}
};
template <> struct access_TCL_obj<class ::ravel::RawDataIdx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::TCL_obj(targ,desc+".normalise",arg,&ravel::RawDataIdx::normalise);
::TCL_obj(targ,desc+".clear",arg,&ravel::RawDataIdx::clear);
::TCL_obj(targ,desc+".renameAxis",arg,&ravel::RawDataIdx::renameAxis);
::TCL_obj(targ,desc+".size",arg,&ravel::RawDataIdx::size);
::TCL_obj(targ,desc+".rank",arg,&ravel::RawDataIdx::rank);
::TCL_obj(targ,desc+".idx",arg,&ravel::RawDataIdx::idx);
::TCL_obj(targ,desc+".offset",arg,&ravel::RawDataIdx::offset);
::TCL_obj(targ,desc+".sizeStride",arg,&ravel::RawDataIdx::sizeStride);
::TCL_obj(targ,desc+".slice",arg,&ravel::RawDataIdx::slice);
::TCL_obj(targ,desc+".removeDimension",arg,&ravel::RawDataIdx::removeDimension);
}
};
template <> struct access_TCL_obj<class ::ravel::RawData > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::TCL_obj_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::TCL_obj_onbase(targ,desc+"",classdesc::base_cast<RawDataIdx >::cast(arg));
::TCL_obj(targ,desc+".clear",arg,&ravel::RawData::clear);
::TCL_obj(targ,desc+".reduce",arg,&ravel::RawData::reduce);
::TCL_obj(targ,desc+".reduceAlong",arg,&ravel::RawData::reduceAlong);
}
};
template <> struct access_isa<struct ::ravel::InvalidKey > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::isa_onbase(targ,desc+"",classdesc::base_cast<std::exception >::cast(arg));
::isa(targ,desc+".what",arg,&ravel::InvalidKey::what);
}
};
template <> struct access_isa<struct ::ravel::RawDataIdx::Idx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::isa(targ,desc+".idx",arg.idx);
::isa(targ,desc+".stride",arg.stride);
}
};
template <> struct access_isa<struct ::ravel::RawDataIdx::SizeStride > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
typedef  RawDataIdx::Idx Idx;
typedef  RawDataIdx::SizeStride SizeStride;
::isa(targ,desc+".size",arg.size);
::isa(targ,desc+".stride",arg.stride);
}
};
template <> struct access_isa<class ::ravel::RawDataIdx > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::isa(targ,desc+".normalise",arg,&ravel::RawDataIdx::normalise);
::isa(targ,desc+".clear",arg,&ravel::RawDataIdx::clear);
::isa(targ,desc+".renameAxis",arg,&ravel::RawDataIdx::renameAxis);
::isa(targ,desc+".size",arg,&ravel::RawDataIdx::size);
::isa(targ,desc+".rank",arg,&ravel::RawDataIdx::rank);
::isa(targ,desc+".idx",arg,&ravel::RawDataIdx::idx);
::isa(targ,desc+".offset",arg,&ravel::RawDataIdx::offset);
::isa(targ,desc+".sizeStride",arg,&ravel::RawDataIdx::sizeStride);
::isa(targ,desc+".slice",arg,&ravel::RawDataIdx::slice);
::isa(targ,desc+".removeDimension",arg,&ravel::RawDataIdx::removeDimension);
}
};
template <> struct access_isa<class ::ravel::RawData > {
template <class _CD_ARG_TYPE>
void operator()(classdesc::isa_t& targ, const classdesc::string& desc,_CD_ARG_TYPE& arg)
{
using namespace ravel;
::isa_onbase(targ,desc+"",classdesc::base_cast<RawDataIdx >::cast(arg));
::isa(targ,desc+".clear",arg,&ravel::RawData::clear);
::isa(targ,desc+".reduce",arg,&ravel::RawData::reduce);
::isa(targ,desc+".reduceAlong",arg,&ravel::RawData::reduceAlong);
}
};
}
#if defined(__GNUC__) && !defined(__ICC) && !defined(__clang__)
#pragma GCC diagnostic pop
#endif
